
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.0">
    
    
      
        <title>MELLE - Sapphire Lab</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.9f615399.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#melle" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../.." title="Sapphire Lab" class="md-header__button md-logo" aria-label="Sapphire Lab" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Sapphire Lab
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              MELLE
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="Sapphire Lab" class="md-nav__button md-logo" aria-label="Sapphire Lab" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Sapphire Lab
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TTS
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../../../PDE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PDE
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#abstract" class="md-nav__link">
    Abstract: 摘要
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1introduction" class="md-nav__link">
    1.Introduction: 引言
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2related-works" class="md-nav__link">
    2.Related Works: 相关工作
  </a>
  
    <nav class="md-nav" aria-label="2.Related Works: 相关工作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#traditional-tts" class="md-nav__link">
    Traditional TTS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zero-shot-tts" class="md-nav__link">
    Zero-Shot TTS
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3methodology" class="md-nav__link">
    3.Methodology: 方法
  </a>
  
    <nav class="md-nav" aria-label="3.Methodology: 方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31problem-formulation-mel-spectrogram-language-modeling" class="md-nav__link">
    3.1.Problem Formulation: Mel-Spectrogram Language modeling
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32architecture" class="md-nav__link">
    3.2.Architecture
  </a>
  
    <nav class="md-nav" aria-label="3.2.Architecture">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#321autoregressive-language-model" class="md-nav__link">
    3.2.1.Autoregressive Language Model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#322latent-sampling-module" class="md-nav__link">
    3.2.2.Latent Sampling Module
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#323stop-prediction-layer-and-post-net" class="md-nav__link">
    3.2.3.Stop Prediction Layer and Post-Net
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33training-objective" class="md-nav__link">
    3.3.Training Objective
  </a>
  
    <nav class="md-nav" aria-label="3.3.Training Objective">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#regression-loss" class="md-nav__link">
    Regression Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kl-divergence-loss" class="md-nav__link">
    KL Divergence Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-spectrogram-flux-loss" class="md-nav__link">
    The Spectrogram Flux Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stop-prediction-loss" class="md-nav__link">
    Stop Prediction Loss
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34inference-in-context-learning-for-mel-spectrogram" class="md-nav__link">
    3.4.Inference: In-Context Learning for Mel-Spectrogram
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4experiments" class="md-nav__link">
    4.Experiments: 实验
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5results" class="md-nav__link">
    5.Results: 结果
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6conclusions" class="md-nav__link">
    6.Conclusions: 结论
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="melle">MELLE<a class="headerlink" href="#melle" title="Permanent link">&para;</a></h1>
<details>
<summary>基本信息</summary>

- 标题: Autoregressive Speech Synthesis without Vector Quantization
- 作者:
  - 01 [Lingwei Meng](../../Authors/Lingwei_Meng.md)
  - 02 [Long Zhou](../../Authors/Long_Zhou_(周龙).md)
  - 03 [Shujie Liu](../../Authors/Shujie_Liu_(刘树杰).md)
  - 04 [Sanyuan Chen](../../Authors/Sanyuan_Chen_(陈三元).md)
  - 05 [Bing Han](../../Authors/Bing_Han.md)
  - 06 [Shujie Hu](../../Authors/Shujie_Hu.md)
  - 07 [Yanqing Liu](../../Authors/Yanqing_Liu.md)
  - 08 [Jinyu Li](../../Authors/Jinyu_Li_(李劲宇).md)
  - 09 [Sheng Zhao](../../Authors/Sheng_Zhao_(赵胜).md)
  - 10 [Xixin Wu](../../Authors/Xixin_Wu.md)
  - 11 [Helen Meng](../../Authors/Helen_Meng_(蒙美玲).md)
  - 12 [Furu Wei](../../Authors/Furu_Wei_(韦福如).md)
- 机构:
  - [香港中文大学](../../Institutions/CUHK_香港中文大学.md)
  - [Microsoft](../../Institutions/Microsoft.md)
- 时间:
  - 预印时间: 2024.07.11 ArXiv v1
  - 更新笔记: 2024.07.12
- 发表:
  - 期刊/会议 
- 链接:
  - [ArXiv](https://arxiv.org/abs/2407.08551)
  <!-- - [DOI]() -->
  <!-- - [Github]() -->
  - [Demo](https://aka.ms/melle)
  <!-- - [Scholar](https://scholar.google.com/scholar?cluster=) -->
- 标签:
  - [自回归](../../Tags/Autoregressive.md)
- 页数: 17
- 引用: ?
- 被引: ?
- 数据:
  - 训练 [Libriheavy](../../Datasets/2023.09.15_Libriheavy.md) MELLE
  - 训练 [LibriSpeech](../../Datasets/2015.04.19_LibriSpeech.md) MELLE-limited
- 对比:
  - [ELLA-V](../../Models/Speech_LLM/2024.01.14_ELLA-V.md)
  - [VALL-E R](../../Models/Speech_LLM/2024.06.12_VALL-E_R.md)
  - [RALL-E](../../Models/Speech_LLM/2024.04.04_RALL-E.md)
  - [CLaM-TTS](../../Models/Speech_LLM/2024.04.03_CLaM-TTS.md)
  - [VALL-E](../../Models/Speech_LLM/2023.01.05_VALL-E.md)
  - [VALL-E 2](../../Models/Speech_LLM/2024.06.08_VALL-E2.md)
  - [Voicebox](../../Models/Speech_LLM/2023.06.23_VoiceBox.md)
- 复现:
  - ?

</details>

<h2 id="abstract">Abstract: 摘要<a class="headerlink" href="#abstract" title="Permanent link">&para;</a></h2>
<blockquote>
<p>We present <strong><em>MELLE</em></strong>, a novel continuous-valued tokens based language modeling approach for text to speech synthesis (TTS).
<strong><em>MELLE</em></strong> autoregressively generates continuous mel-spectrogram frames directly from text condition, bypassing the need for vector quantization, which are originally designed for audio compression and sacrifice fidelity compared to mel-spectrograms.
Specifically, (i) instead of cross-entropy loss, we apply regression loss with a proposed spectrogram flux loss function to model the probability distribution of the continuous-valued tokens. (ii) we have incorporated variational inference into <strong><em>MELLE</em></strong> to facilitate sampling mechanisms, thereby enhancing the output diversity and model robustness.
Experiments demonstrate that, compared to the two-stage codec language models VALL-E and its variants, the single-stage <strong><em>MELLE</em></strong> mitigates robustness issues by avoiding the inherent flaws of sampling discrete codes, achieves superior performance across multiple metrics, and, most importantly, offers a more streamlined paradigm.
See https://aka.ms/melle for demos of our work.</p>
</blockquote>
<h2 id="1introduction">1.Introduction: 引言<a class="headerlink" href="#1introduction" title="Permanent link">&para;</a></h2>
<blockquote>
<p>The objective of next-token prediction, which involves predicting the next discrete token based on the previous tokens as condition, is foundational to the recent progress observed in autoregressive large language models (LLMs).
Recently, the success of LLMs in natural language processing (NLP) tasks has encouraged the exploration of autoregressive language modeling approaches in audio synthesis fields (<a href="../../Models/Speech_LLM/2022.09.07_AudioLM.md">AudioLM</a>; <a href="../2023.01.05_VALL-E/">VALL-E</a>). 
Neural codec language models, exemplified by <a href="../2023.01.05_VALL-E/">VALL-E</a> and <a href="../../Models/Speech_LLM/2023.03.07_VALL-E_X.md">VALL-E X</a>, reveal the potential of such principle in the zero-shot text-to-speech (TTS) task via leveraging large-scale multi-lingual multi-speaker multi-domain training corpus. 
Unlike traditional TTS systems that rely heavily on complex and multi-step pipelines, they utilize a decoder-only approach to predict neural codec codes, which are discrete tokens encoded from continuous waveforms leveraging neural codec models (<a href="../../Speech_Neural_Codec/2021.07.07_SoundStream/">SoundStream</a>; <a href="../../Speech_Neural_Codec/2022.10.24_EnCodec/">EnCodec</a>). </p>
<p>Although achieving impressive naturalness and diversity in synthesized audios, VALL-E and its variants are plagued by following several drawbacks.
First, neural codec codes, originally designed for audio compression, exhibit lower fidelity compared to the well-established mel-spectrogram \citep{puvvada2024discrete}.
This phenomenon is also observed in the field of graphics, where the reconstruction quality of vector-quantized tokenizers typically lags behind that of their continuous-valued counterparts \citep{rombach2022high,huang2023not,kaiming2024autoregressive}.
Second, the codec language model VALL-E suffers from robustness issues stemming from its random sampling strategy, which is inherited from text language model for selecting discrete tokens.
This issue is more pronounced with acoustic tokens as opposed to textual ones due to the greater similarity among consecutive codec codes, which can lead to continuous stretches of silence or persistent noise (<a href="../2023.01.05_VALL-E/">VALL-E</a>; <a href="../2024.01.14_ELLA-V/">ELLA-V</a>).
Third, neural codec language models typically necessitate a complicated two-pass decoding process, involving an autoregressive (AR) model for generating coarse primary audio tokens, followed by a non-autoregressive (NAR) model to iteratively predict the rest multiple codebook codes for refinement. 
This multi-step procedure compromises inference efficiency, leading to increased computational demands and doubled storage requirements.</p>
<p>To address the limitations associated with discrete tokens based codec language models, we are rethinking the potential of continuous speech representations and aim to determine whether continuous-valued tokens can supplant discrete-valued tokens within the paradigm of autoregressive speech synthesis models.
The successful implementation of the autoregressive model without discrete vector quantization faces two key challenges.
- <strong>How to set training objective for continuous representation?</strong>
The continuous space significantly differs from that of vector-quantized tokens, for which autoregressive language models typically adopt a next-token prediction objective, with cross-entropy loss to measure the discrepancy between the predicted distribution and the ground truth. 
- <strong>How to enable sampling mechanism in continuous space?</strong>
The sampling strategy is a critical component in both text generation and speech synthesis systems, as it introduces diversity into the output and enhances the generalization ability.
However, continuous-valued tokens based models can not employ top-p random sampling method used in discrete codec language models.</p>
<p>In this work, we propose a continuous mel-spectrogram\footnote{We leave the exploration of other continuous representations, such as VAE latent hidden states, for future research endeavors.} based autoregressive language model (called <strong><em>MELLE</em></strong>) for text-to-speech synthesis, as illustrated in Figure \ref{fig:overview}. <strong><em>MELLE</em></strong> is a robust single-pass zero-shot TTS model which autoregressively predicts mel-spectrogram frames based on previous mel-spectrogram and text tokens, thereby avoiding the inherent flaws associated with sampling discrete codec codes. 
The mel-spectrogram is then converted into waveform utilizing an off-the-shelf vocoder. 
In response to the aforementioned challenges, we first substitute cross-entropy loss with regression loss and introduce a spectrogram flux loss to promote variation of predicted mel-spectrograms and eliminate repetition issues.
Second, we design a latent sampling module, derived from variational inference, functions as a sequence sampling strategy thereby enhancing the diversity of the generated audio samples. 
As an option, by adjusting the reduction factor, <strong><em>MELLE</em></strong> can predict multiple frames at one step and accelerate inference, thereby further alleviating the robustness issues associated with long-sequence modeling and maintaining satisfactory performance. </p>
<p>We conducted evaluations of our <strong><em>MELLE</em></strong> on both the large-scale 50K-hour <a href="../../Datasets/2023.09.15_Libriheavy.md">Libriheavy</a> training dataset and the relatively small 960-hour <a href="../../Datasets/2015.04.19_LibriSpeech.md">LibriSpeech</a> training dataset. 
Following recent works, we use LibriSpeech test-clean set for zero-shot TTS evaluation.
Experimental results demonstrate that the proposed <strong><em>MELLE</em></strong> is on par with <a href="../2024.06.08_VALL-E2/">VALL-E 2</a> in objective metrics, and surpasses VALL-E 2 in subjective metrics.
It also outperforms previous neural codec language models, including VALL-E and its other variants, achieving superior performance across multiple metrics that reflect naturalness, robustness, similarity, and inference efficiency. </p>
<p>Specifically, <strong><em>MELLE</em></strong> surpasses the ground truth audios in WER (1.47\% vs. 1.61\%), achieving a 47.9\% relative reduction in WER compared to VALL-E and an 8.1\% reduction compared to VALL-E 2 on the continuation inference task for zero-shot TTS. 
For subjective evaluations, <strong><em>MELLE</em></strong> is more favorably received by human listeners than previous models, achieving comparable performance to the original ground truth in terms of MOS (4.20 vs. 4.29) and CMOS (-0.032 for ours vs. ground truth), and an even higher SMOS (4.40 vs. 3.94) than the ground-truth speech.</p>
</blockquote>
<h2 id="2related-works">2.Related Works: 相关工作<a class="headerlink" href="#2related-works" title="Permanent link">&para;</a></h2>
<h3 id="traditional-tts">Traditional TTS<a class="headerlink" href="#traditional-tts" title="Permanent link">&para;</a></h3>
<blockquote>
<p>Traditional speech synthesis methods can be categorized concatenative systems, parametric systems, and end-to-end neural systems.
Concatenative TTS systems deconstruct original audio waves into smaller segments and then reassembles them using algorithms like Viterbi, followed by signal processing techniques, to create new audio waves.
Parametric TTS systems convert speech waves into spectrograms, utilizing acoustic parameters such as fundamental frequency and duration to synthesize new audio outputs.
With the rapid development of neural networks, end-to-end neural TTS systems are proposed to simplify previous speech synthesis pipeline via a single neural network, eliminating the need for the production of these linguistic and acoustic features (<a href="../../TTS2_Acoustic/2017.03.29_Tacotron/">Tacotron</a>; <a href="../../Models/TTS2_Acoustic/2018.09.19_Transformer_TTS.md">TransformerTTS</a>; <a href="../../Models/TTS2_Acoustic/2019.05.22_FastSpeech.md">FastSpeech</a>).</p>
<p>The advanced end-to-end neural TTS models, such as <a href="../../TTS2_Acoustic/2017.03.29_Tacotron/">Tacotron</a>, <a href="../../Models/TTS2_Acoustic/2018.09.19_Transformer_TTS.md">TransformerTTS</a>, and <a href="../../Models/TTS2_Acoustic/2019.05.22_FastSpeech.md">FastSpeech</a>, usually generate mel-spectrograms directly from texts, then synthesize the audio results from the mel-spectrogram by a vocoder such as <a href="../../TTS3_Vocoder/2016.09.12_WaveNet/">WaveNet</a>.
TransformerTTS employs Transformer-based encoder-decoder network as the main framework to replace RNN structures in Tacotron.
FastSpeech further improve the speech quality and decoding efficiency using the non-autoregressive generation model with a duration module.
These model are trained on small-scale, clean, single-speaker or few-speaker dataset, such as LJSpeech and LibriTTS.
Our <strong><em>MELLE</em></strong> leverages the well-established mel-spectrogram as the intermediate representation, however, it differs significantly in two key aspects: 
(1) we adopt decoder-only network as foundational structure with improved methods, such as variational inference and spectrogram flux loss, 
(2) <strong><em>MELLE</em></strong> is capable of zero-shot TTS via training on large-scale speech-text paired data, like <a href="../../Datasets/2023.09.15_Libriheavy.md">Libriheavy</a>.</p>
</blockquote>
<h3 id="zero-shot-tts">Zero-Shot TTS<a class="headerlink" href="#zero-shot-tts" title="Permanent link">&para;</a></h3>
<blockquote>
<p>Motivated by the zero-shot and in-context learning capabilities of large language models (LLMs) on natural language processing (NLP) tasks, various research works are proposed to address zero-shot TTS through a language modeling approach.
<a href="../2023.01.05_VALL-E/">VALL-E</a> first regards TTS tasks as a conditional language task, which utilizes neural codec codes as intermediate representation instead of mel-spectrogram, then uses a codec decoder to recover the waveform from predicted codec codes.
VALL-E employs two-stage modeling method, with an autoregressive model for generating coarse audio tokens, followed by a non-autoregressive model to iteratively predict multi-codebook codes for refinement.
<a href="../../Models/Speech_LLM/2023.03.07_VALL-E_X.md">VALL-E X</a> extends VALL-E into multi-lingual scenario to support zero-shot cross-lingual speech synthesis and speech-to-speech translation.
<a href="../2023.06.06_Mega-TTS/">Mega-TTS</a> proposes to disentangle the multiple attributes in speech, such as content, timbre, prosody, and phase attributes, then model each of them according to their intrinsic properties with a language modeling approach.
<a href="../2024.01.14_ELLA-V/">ELLA-V</a>, <a href="../2024.04.04_RALL-E/">RALL-E</a>, and <a href="../2024.06.12_VALL-E_R/">VALL-E R</a> aims to improve robustness and stability of VALL-E via additional fine-grained speech-text alignment information. 
<a href="../../Models/Speech_LLM/2024.02.12_BASE-TTS.md">BASE TTS</a> employs discrete tokens derived from <a href="../../Models/Speech_Representaion/2021.10.26_WavLM.md">WavLM</a> and scales the codec language model to larger parameters and training data.
<a href="../../Models/Speech_LLM/Seed-TTS.md">Seed-TTS</a> replaces NAR model in VALL-E with a diffusion model, which generates continuous speech representations according generated speech tokens from AR stage. 
In parallel to our work, <a href="../2024.06.08_VALL-E2/">VALL-E 2</a> shares the same architecture as VALL-E but employs a repetition-aware sampling strategy that promotes more deliberate sampling choices.</p>
<p>Other studies have investigated fully non-autoregressive approaches to increase the speed of model inference.
For instance, <a href="../2023.05.16_SoundStorm/">SoundStorm</a> adapts a parallel, non-autoregressive, confidence-based decoding scheme for the generation of codec codes.
<a href="../../Models/Speech_LLM/2023.06.13_StyleTTS2.md">StyleTTS2</a> and <a href="../../Models/Diffusion/2024.03.05_NaturalSpeech3.md">NaturalSpeech 3</a> use diffusion model to achieve better TTS synthesis.
<a href="../../Models/Speech_LLM/2023.06.23_VoiceBox.md">Voicebox</a> and <a href="../../Models/Speech_LLM/2023.12.25_Audiobox.md">Audiobox</a> employ non-autoregressive flow-matching based models for transcript-guided speech generation.
Recently, <a href="../../Models/_tmp/2024.06.26_E2_TTS.md">E2 TTS</a> presents a fully non-autoregressive TTS systems consisting of flow-matching-based mel-spectrogram generator trained with the audio infilling task, and a vocoder.
Different previous works, <strong><em>MELLE</em></strong> leverages continuous-valued tokens based autoregressive language modeling approach with variational inference for text-to-speech synthesis. </p>
</blockquote>
<h2 id="3methodology">3.Methodology: 方法<a class="headerlink" href="#3methodology" title="Permanent link">&para;</a></h2>
<h3 id="31problem-formulation-mel-spectrogram-language-modeling">3.1.Problem Formulation: Mel-Spectrogram Language modeling<a class="headerlink" href="#31problem-formulation-mel-spectrogram-language-modeling" title="Permanent link">&para;</a></h3>
<blockquote>
<p>This study regards zero-shot TTS as an autoregressive mel-spectrogram language modeling task.
Instead of predicting highly-compressed neural codec codes like VALL-E and its variants, ~<strong><em>MELLE</em></strong> directly predicts continuous mel-spectrograms which are then converted to waveforms with an off-the-shelf vocoder.
Taking well-established mel-spectrogram as the training target, it strives to achieve higher fidelity and naturalness.</p>
<p>Given an audio sample with byte-pair-encoded (BPE) text content $\bm{x} = [x_0, x_1, \ldots, x_{L-1}]$, <strong><em>MELLE</em></strong> is optimized to predict the mel-spectrogram $\bm{y} = [\bm{y}<em>0, \bm{y}_1, \ldots, \bm{y}</em>{T-1}]$ extracted from the corresponding audio.
Specifically, at each autoregressive step, <strong><em>MELLE</em></strong> is expected to predict the next mel-spectrogram frame $\bm{y}<em>{t}$ conditioned on the text prompt $\bm{x}$ and the previous generated mel-spectrograms $\bm{y}</em>{&lt;t}$, which is equivalent to maximizing the following distribution:</p>
<p>$$
p(\bm{y} \mid \bm{x}; \theta) = \prod_{t=0}^{T-1} p(\bm{y}<em>t \mid \bm{y}</em>{&lt;t}, \bm{x}; \theta)\tag{01}
$$</p>
<p>where $\bm{y}<em>{&lt;t}$ denotes $[\bm{y}_0, \bm{y}_1,..., \bm{y}</em>{t-1}]$ and $\theta$ represents the parameters of <strong><em>MELLE</em></strong>. </p>
<p>Inspired by previous neural TTS models (<a href="../../Models/TTS2_Acoustic/2018.09.19_Transformer_TTS.md">TransformerTTS</a>), we can also set a reduction factor $r$ (e.g., 2 or 4) to control the number of mel-spectrogram frames predicted at each decoding step, providing a balance between computational efficiency and the generation of high-quality speech.
Formally, the original mel-spectrogram sequences $\bm{y}$ will be partitioned into $\bm{y}^r = [\bm{y}<em>{0:r}, \bm{y}</em>{r:2r}, ..., \bm{y}_{(T-r):T}]$ with reduction factor $r$, and the likelihood function can be expressed as follows:</p>
<p>$$
p(\bm{y} \mid \bm{x}; \theta) = \prod_{t=0}^{T/r-1} p(\bm{y}<em>{t\cdot r:(t+1)\cdot r} \mid \bm{y}</em>{&lt;t\cdot r}, \bm{x}; \theta)\tag{02}
$$</p>
<p>During inference, <strong><em>MELLE</em></strong> executes zero-shot TTS tasks via prompting like VALL-E.
Given the text content $\bm{x}$ for synthesis, text transcription $\tilde{\bm{x}}$ and mel-spectrogram $\tilde{\bm{y}}$ of speech prompt, the model is designed to generate the target mel-spectrogram $\bm{y}$ of the corresponding content while preserving the characteristics of the original speaker in prompt, with maximum likelihood probability as $\argmax_{\bm{y}} p(\bm{y}<em>{t\cdot r:(t+1)\cdot r} \mid [\tilde{\bm{x}}; \bm{x}; \tilde{\bm{y}}; \bm{y}</em>{&lt;t\cdot r}]; \theta)$ at each step, where $[;]$ means concatenation operation and it backs to standard mode if $r=1$.</p>
</blockquote>
<h3 id="32architecture">3.2.Architecture<a class="headerlink" href="#32architecture" title="Permanent link">&para;</a></h3>
<blockquote>
<p>As illustrated in Figure \ref{fig:overview}, <strong><em>MELLE</em></strong> comprises the following main components: pre-nets that respectively convert text into sub-word tokens and extract mel-spectrograms from speech, before projecting them to the model dimension; an autoregressive (AR) Transformer decoder that serves as the language model; a latent sampling module that samples latent embedding from a predicted Gaussian distribution, and then projects it back to the spectrogram space; a stop prediction layer that determines the end of the speech and a convolutional post-net for spectrogram refinement, similar to the methods described in (<a href="../../Models/TTS2_Acoustic/2017.12.16_Tacotron2.md">Tacotron2</a>; <a href="../../Models/TTS2_Acoustic/2018.09.19_Transformer_TTS.md">TransformerTTS</a>).
Finally, a vocoder is used to recover the speech from generated mel-spectrogram. </p>
<p>Unlike neural codec language models that iteratively predict multi-layer codec codes, we do not require an additional non-autoregressive (NAR) model thanks to the completeness of the mel-spectrogram.
This simplification significantly improve computational and storage efficiency.
Moreover, by adjusting the reduction factor, <strong><em>MELLE</em></strong> can generate multiple mel-spectrogram frames at one step, further enhancing efficiency while still maintaining superior performance.</p>
</blockquote>
<h4 id="321autoregressive-language-model">3.2.1.Autoregressive Language Model<a class="headerlink" href="#321autoregressive-language-model" title="Permanent link">&para;</a></h4>
<blockquote>
<p>We employ a unidirectional Transformer decoder as the language model (LM) to autoregressively generates acoustic continuous features based on the textual input and acoustic prompts.
Specifically, input text tokens $\bm{x}$, with an appended <EOS> token, are first converted into embeddings by the text embedding layer based on their indices. 
Simultaneously, we employ a multi-layer perceptron, named pre-net, to project the mel-spectrogram $\bm{y}$ to the language model dimension.
The LM, consisting of blocks of multi-head attention and feed-forward layers, takes the concatenation of text and acoustic embeddings as input to model the dependency between semantic and acoustic information.
The output of the LM $\bm{e}_t$ at time step $t$ is subsequently processed by the following modules of <strong><em>MELLE</em></strong> to synthesize the next-frame output, which is detailed in the following section.</p>
</blockquote>
<h4 id="322latent-sampling-module">3.2.2.Latent Sampling Module<a class="headerlink" href="#322latent-sampling-module" title="Permanent link">&para;</a></h4>
<blockquote>
<p>Sampling strategy is an critical part in TTS systems, as it not only introduces diversity in the output, but also enhances the generalization ability of the model. 
For example, Tacotron-like models (<a href="../../TTS2_Acoustic/2017.03.29_Tacotron/">Tacotron</a>; <a href="../../Models/TTS2_Acoustic/2017.12.16_Tacotron2.md">Tacotron2</a>) enable dropout in their pre-net during inference to introduce variation;
Neural codec language models (<a href="../2023.01.05_VALL-E/">VALL-E</a>; <a href="../../Models/Speech_LLM/2023.03.07_VALL-E_X.md">VALL-E X</a>) adopt the top-p random sampling to avoid the collapse outputs leading by greedy search; Diffusion-based (<a href="../../Diffusion/2023.04.18_NaturalSpeech2/">NaturalSpeech2</a>; <a href="../../Models/Diffusion/2024.03.05_NaturalSpeech3.md">NaturalSpeech3</a>) and flow-matching-based methods (<a href="../../Models/Speech_LLM/2023.06.23_VoiceBox.md">Voicebox</a>) restore speech representations from the sampling of a simpler distribution. </p>
<p>In this study, inspired by variational autoencoders (VAEs) \citep{kingma2014vae, blei2017vi_review}, we integrate a novel latent sampling module within <strong><em>MELLE</em></strong>, aimed at enhancing both expressive diversity and robustness, as shown in Figure \ref{fig:modules} (left).
Based on $\bm{e}_t$, the output of the LM, this module predicts a distribution, from which a latent embedding $\bm{z}_t$ is sampled. %This latent embedding is then mapped to the mel-spectrogram space.</p>
<p>Specifically, we assume that $\bm{z}_t$ follows a multivariate Gaussian distribution where each dimension is independent.
As depicted in Figure \ref{fig:modules}, a linear layer ($\mathbf{W} [\cdot] + \mathbf{b}$) predicts a mean vector $\boldsymbol{\mu}_t$ and a log-magnitude variance vector $\log\bm{\sigma}_t^2$ of the multivariate Gaussian distribution based on $\bm{e}_t$.
Leveraging the reparameterization technique, a $\bm{z}_t$ is sampled as
$$
\begin{aligned}
&amp;\bm{z}_t = \bm{\mu}_t + \bm{\sigma}_t \odot \bm{\epsilon} \ \text{where}\quad\bm{\epsilon} &amp;\sim \mathcal{N}(0, \bm{I}), \quad  [\bm{\mu}_t, \log \bm{\sigma}_t^2] = \mathbf{W} \bm{e}_t + \mathbf{b}
\end{aligned}
$$</p>
<p>Therefore, the probability density function can be defined as
$$
\begin{aligned}
&amp;p_\theta(\bm{z}_t \mid \bm{e}_t) = \mathcal{N}(\bm{z}_t \mid \bm{\mu}_t, \mathrm{diag}(\bm{\sigma}_t^2)) 
\end{aligned}
$$</p>
<p>Note that the latent sampling module is differentiable with the reparameterization technique.
Next, the latent variable $\bm{z}<em>t$ is passed through a multi-layer perceptron (MLP) with residual connections, mapping it to the mel-spectrogram space as $\bm{y}'</em>{t}$, where $t=0, 1, ..., T-1$.</p>
</blockquote>
<h4 id="323stop-prediction-layer-and-post-net">3.2.3.Stop Prediction Layer and Post-Net<a class="headerlink" href="#323stop-prediction-layer-and-post-net" title="Permanent link">&para;</a></h4>
<blockquote>
<p>Since <strong><em>MELLE</em></strong> directly predicts continuous mel-spectrograms rather than discrete tokens, it cannot generate an <EOS> token to indicate the end of generation.
Instead, we use a linear layer as a binary classifier, taking $\bm{e}<em>t$ to determine if the generation should conclude, as depicted in Figure \ref{fig:modules} (mid).
Following previous neural TTS models (<a href="../../TTS2_Acoustic/2017.03.29_Tacotron/">Tacotron</a>; <a href="../../Models/TTS2_Acoustic/2017.12.16_Tacotron2.md">Tacotron2</a>), we employ multiple convolutional blocks as the post-net to produce a residual that is added to $\bm{y}'={\bm{y}'</em>{0}, \bm{y}'<em>{1}, ..., \bm{y}'</em>{T-1}}$, resulting in the refined mel-spectrogram $\bm{y}''={\bm{y}''<em>{0}, \bm{y}''</em>{1}, ..., \bm{y}''_{T-1}}$, as shown in Figure \ref{fig:modules} (right). 
During training, the model is trained using teacher-forcing; while during inference, post-net processes $\bm{y}'$ after the AR generation concludes.</p>
</blockquote>
<h3 id="33training-objective">3.3.Training Objective<a class="headerlink" href="#33training-objective" title="Permanent link">&para;</a></h3>
<blockquote>
<p>The training process of <strong><em>MELLE</em></strong> is efficient and straightforward, due to the absence of \mbox{VALL-E}'s complex hierarchical structure.
As illustrated in Figure \ref{fig:overview}, during training, a single end-to-end autoregressive model is optimized with the teacher-forcing manner using four loss functions: (1) a regression loss; (2) a Kullback-Leibler (KL) divergence loss; (3) a novel spectrogram flux loss; and (4) a binary cross entropy (BCE) loss for stop prediction.
They work collaboratively to enhance overall performance:</p>
</blockquote>
<p>$$
\begin{aligned}
\mathcal{L} = \mathcal{L}<em>{\text{reg}} + \lambda \mathcal{L}</em>{\text{KL}} + \beta\mathcal{L}<em>{\text{flux}} + \gamma \mathcal{L}</em>{\text{stop}}
\end{aligned}
$$</p>
<h4 id="regression-loss">Regression Loss<a class="headerlink" href="#regression-loss" title="Permanent link">&para;</a></h4>
<blockquote>
<p>The regression loss is a fundamental component of the training objective, ensuring the accurate prediction of mel-spectrogram frames, like conventional TTS (<a href="../../Models/TTS2_Acoustic/2018.09.19_Transformer_TTS.md">TransformerTTS</a>).
The regression loss, (\mathcal{L}_{\text{reg}}), is composed of a combination of L1 and L2 losses, applied to both intermediate prediction $\bm{y}'$ and final prediction $\bm{y}''$ of the mel-spectrogram.
It is defined as follows:</p>
</blockquote>
<p>$$
\begin{aligned}
\mathcal{L}<em>{\text{reg}}(\bm{y}, \bm{y}', \bm{y}'')
   &amp;= \mathcal{L}</em>{\text{L1}}(\bm{y}, \bm{y}') + \mathcal{L}<em>{\text{L2}}(\bm{y}, \bm{y}') + \mathcal{L}</em>{\text{L1}}(\bm{y}, \bm{y}'') + \mathcal{L}_{\text{L2}}(\bm{y}, \bm{y}'') \notag \
   &amp;= |\bm{y} - \bm{y}'|_1 + |\bm{y} - \bm{y}'|_2^2 + |\bm{y} - \bm{y}''|_1 + |\bm{y} - \bm{y}''|_2^2
\end{aligned}
$$</p>
<blockquote>
<p>where $\bm{y}$ represents the ground-truth mel-spectrogram target.</p>
</blockquote>
<h4 id="kl-divergence-loss">KL Divergence Loss<a class="headerlink" href="#kl-divergence-loss" title="Permanent link">&para;</a></h4>
<blockquote>
<p>We introduce a Kullback-Leibler (KL) divergence loss based on the concept of variational inference \citep{kingma2014vae, blei2017vi_review}, to enhance the diversity and stability of <strong><em>MELLE</em></strong>.
The KL divergence measures the difference between the predicted latent distribution ( p_\theta(\bm{z}_t \mid \bm{e}_t) ) and a simpler distribution ( p(\bm{z}_t) ).
Unlike \cite{kingma2014vae}, which selects ( p(\bm{z}_t) ) as a standard normal distribution, we let (\bm{z}_t) possess the same dimensionality as the mel-spectrogram and define ( p(\bm{z}_t) ) as (\mathcal{N}(\bm{y}_t, \bm{I})). 
This can be seen as a shortcut on the optimization path thus accelerates the model's learning.
Combining equation (\ref{eq:gaussian}), the KL divergence loss among $T$ time steps can be analytically computed as</p>
</blockquote>
<p>$$
\begin{aligned}
\mathcal{L}<em>\text{KL}(\bm{y}, \bm{z}) &amp;= \sum</em>{t=0}^{T-1} D_{\text{KL}}(p_\theta(\bm{z}<em>t \mid \bm{e}_t) \parallel p(\bm{z}_t)) \notag\
&amp;=\frac{1}{2} \sum</em>{t=0}^{T-1} \sum_{i=1}^d \left( \bm{\sigma}_t^2[i] + (\bm{\mu}_t[i]-\bm{y}_t[i])^2 - 1 - \log\bm{\sigma}_t^2[i] \right) 
\end{aligned}
$$</p>
<blockquote>
<p>where ( d ) is the dimensionality of the feature space.
The detailed derivation is provided in Appendix \ref{appendix:derivation}.
By integrating the KL divergence into the loss function, <strong><em>MELLE</em></strong> achieves a balance between reconstruction quality and latent space regularization, ultimately contributing to enhanced expressive diversity and robustness of the generated mel-spectrograms. </p>
</blockquote>
<h4 id="the-spectrogram-flux-loss">The Spectrogram Flux Loss<a class="headerlink" href="#the-spectrogram-flux-loss" title="Permanent link">&para;</a></h4>
<blockquote>
<p>To encourage the dynamic variation of the generated mel-spectrogram frames, we propose a novel spectrogram flux loss as a regularization term.
This loss function penalizes low variability between consecutive frames, thereby promoting changes and preventing the generation of overly static mel-spectrograms:</p>
</blockquote>
<p>$$
\begin{aligned}
\mathcal{L}<em>{\text{flux}}(\bm{y}, \bm{\mu}) = - \sum</em>{t=1}^{T-1} |\bm{\mu}<em>t - \bm{y}</em>{t-1}|_1
\end{aligned}
$$</p>
<blockquote>
<p>where the L1 norm is employed to measure the difference between the predicted Gaussian mean vector $\bm{\mu}<em>t$ and the previous ground truth frame $\bm{y}</em>{t-1}$.
By summing the negative value of the differences, the loss function rewards variations between frames, and the model is encouraged to reduces the generation of overly static frames that leading to repetition or endless silence in synthesized audio. </p>
<p>Additionally, by penalizing flat predictions, the model is incentivized to produce more diverse and dynamic frame sequences, thereby preventing monotonic and unnatural speech.</p>
</blockquote>
<h4 id="stop-prediction-loss">Stop Prediction Loss<a class="headerlink" href="#stop-prediction-loss" title="Permanent link">&para;</a></h4>
<blockquote>
<p>We use a linear layer to project the output of the LM to a logit and calculate the BCE loss, $\mathcal{L}_{\text{stop}}$, for stop prediction, like <a href="../../Models/TTS2_Acoustic/2018.09.19_Transformer_TTS.md">TransformerTTS</a> and <a href="../../Models/_tmp/SpeechT5.md">SpeechT5</a>. 
During this calculation, positive and negative frames are extremely imbalanced, as each utterance has only one positive frame indicating "stop." To address this, we impose a larger weight (100) for the positive frames in the BCE loss.</p>
</blockquote>
<h3 id="34inference-in-context-learning-for-mel-spectrogram">3.4.Inference: In-Context Learning for Mel-Spectrogram<a class="headerlink" href="#34inference-in-context-learning-for-mel-spectrogram" title="Permanent link">&para;</a></h3>
<blockquote>
<p>During inference, we perform zero-shot text-to-speech by autoregressively predicting the mel-spectrogram. 
Given the text content $\bm{x}$ for synthesis, and a piece of speech prompt (with text transcription $\tilde{\bm{x}}$ and mel-spectrogram $\tilde{\bm{y}}$), at each time step ( t ), <strong><em>MELLE</em></strong> generates the next-frame mel-spectrogram ( \bm{y}<em>t' ) from a latent embedding ( \bm{z}_t ), which is sampled from a distribution conditioned on the concatenation of $\tilde{\bm{x}}$, $\bm{x}$, $\tilde{\bm{y}}$, and $\bm{y}</em>{&lt;t}$.
After the AR generation process concludes, the coarse mel-spectrogram ( \bm{y}' ) passes through the post-net to obtain the refined spectrogram ( \bm{y}'' ), which is then converted to speech audio using an off-the-shelf vocoder.
If the reduction factor $r$ is set, the input and predicted mel-spectrograms will be grouped by that factor. </p>
<p>In contrast to neural codec language models (e.g., VALL-E) that rely on multi-stage iterative predictions across multi-layer codec codes and require the manual configuration of sampling parameters, <strong><em>MELLE</em></strong> accomplishes speech synthesis in a single forward pass and automatically samples from learned distributions that are unique to each input. 
This automated approach ensures adaptive and consistent sampling, reduces human effort, and makes the method domain-independent.
With the strong in-context learning capability from LLM, <strong><em>MELLE</em></strong> is capable of generating high-fidelity, natural-sounding speech for unseen speakers without fine-tuning. </p>
</blockquote>
<h2 id="4experiments">4.Experiments: 实验<a class="headerlink" href="#4experiments" title="Permanent link">&para;</a></h2>
<h2 id="5results">5.Results: 结果<a class="headerlink" href="#5results" title="Permanent link">&para;</a></h2>
<h2 id="6conclusions">6.Conclusions: 结论<a class="headerlink" href="#6conclusions" title="Permanent link">&para;</a></h2>
<blockquote>
<p>In this study, we propose a continuous acoustic representation-based language modeling approach for zero-shot text-to-speech synthesis tasks, thereby eliminating the use of discrete vector quantization.
By exploring the potential of mel-spectrograms within the paradigm of language modeling, the proposed <strong><em>MELLE</em></strong> directly predicts mel-spectrograms conditioned on text content and speech prompt.
This approach eliminates the need for the two-pass training and inference procedures typical of neural codec language model VALL-E, and can further accelerate decoding by setting the reduction factor. 
With the aid of latent sampling and spectrogram flux loss, <strong><em>MELLE</em></strong> is capable of producing more diverse and robust predictions, attaining results comparable to human performance in subjective evaluations.</p>
</blockquote>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../../..", "features": [], "search": "../../../../assets/javascripts/workers/search.a264c092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../../assets/javascripts/bundle.4e0fa4ba.min.js"></script>
      
    
  </body>
</html>